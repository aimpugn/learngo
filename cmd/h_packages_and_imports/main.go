package main

import (
	"fmt"
	"math"
	"math/rand" // math ì•ˆì— randê°€ ìˆë‹¤ê³  í•˜ë”ë¼ë„, ëª…ì‹œì ìœ¼ë¡œ import í•´ì•¼ í•œë‹¤
	"strings"
	"time"
	"unicode/utf8"
)

/*
	Package?
	> í•œ ì˜ì—­ì˜ ê¸°ëŠ¥(functionality)ì— ì§‘ì¤‘
	> ëŒ€ë¶€ë¶„ì˜ Go í”„ë¡œê·¸ë¨ì€ ì—¬ëŸ¬ íŒ¨ì§€í‚¤ë¡œ ìª¼ê°œì§ˆ ìˆ˜ ìˆë‹¤
	> Go í”„ë¡œê·¸ë¨ì—ì„œ ê° ë””ë ‰í† ë¦¬ëŠ” ìœ ë‹ˆí¬í•œ íŒ¨í‚¤ì§€ì™€ ì—°ê´€(associated)ëœë‹¤
	> í¬ê²Œ ë‚´ê°€ ìƒì„±í•œ íŒ¨í‚¤ì§€, ë‚¨ì´ ìƒì„±í•œ íŒ¨í‚¤ì§€, í‘œì¤€ íŒ¨í‚¤ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¸ ì¢…ë¥˜ì˜ íŒ¨í‚¤ì§€ ì¡´ì¬

	Import?
	> íŒ¨í‚¤ì§€ê°€ import ë˜ì§€ ì•Šìœ¼ë©´ íŒ¨í‚¤ì§€ì˜ ì½”ë“œì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤
	> ì´ëŠ” ìë°”ì™€ ë‹¤ë¥¸ë°, íŒ¨í‚¤ì§€ë¥¼ import í•œë‹¤ëŠ” ê²ƒì€ ë‹¨ìˆœíˆ ë” ì§§ì€ ì´ë¦„ìœ¼ë¡œ ê·¸ ì•ˆì˜ ì½”ë“œë¥¼ ì°¸ì¡°í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸
	> Javaì™€ Pythonì—ì„œëŠ” íŒ¨í‚¤ì§€ì—ì„œ í•œ í•­ëª©ë§Œ ì„í¬íŠ¸í•  ìˆ˜ ìˆì§€ë§Œ, Goì—ì„œëŠ” ì´ë¥¼ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©°, íŒ¨í‚¤ì§€ ì„í¬íŠ¸ í•˜ë©´ íŒ¨í‚¤ì§€ì˜ ëª¨ë“  ê²ƒì— ëŒ€í•œ ì ‘ê·¼ ê°€ëŠ¥
*/

/*
	GoëŠ” ë‚´ì¥ íƒ€ì…ì— ë©”ì„œë“œë¥¼ ë‘ì§€ ì•Šê³ , í•´ë‹¹ ê¸°ëŠ¥ì„ ì œê³µí•˜ê¸° ìœ„í•´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— íŒ¨í‚¤ì§€ë¥¼ ê°€ì§€ê³  ìˆë‹¤
	string packageì—ëŠ” UTF-8ë¡œ ì‹±í–‰ë˜ëŠ” í•¨ìˆ˜ ì—†ìœ¼ë©°, í•´ë‹¹ í•¨ìˆ˜ëŠ” Unicode/UTF-8 íŒ¨í‚¤ì§€ì— ìˆë‹¤
	ê°€ë ¹ lenì˜ ê²½ìš° ë¬¸ìì—´ì˜ ë°”ì´íŠ¸ì˜ ìˆ˜ë¥¼ ë°˜í™˜í•˜ë©°, ì‹¤ì œ ë¬¸ìì—´ì˜ ë¬¸ì ìˆ˜ë¥¼ ì•Œê³  ì‹¶ë‹¤ë©´ UTF-8 RuneCountInString í•¨ìˆ˜ ì‚¬ìš©
*/
func stringsPkgs() {
	s1 := "This is a test 123 ğŸ˜"
	/*
		Map ë©”ì„œë“œëŠ” mapping í•¨ìˆ˜ì— ë”°ë¼ ìˆ˜ì •ëœ ë¬¸ìë“¤ì˜ ë³µì‚¬ë³¸ì„ ë°˜í™˜ë‹¨ë‹¤
		ë§Œì•½ mappingì´ negative valueë¥¼ ë°˜í™˜í•˜ë©´, í•´ë‹¹ ë¬¸ìê°€ ì¹˜í™˜ ì—†ì´ ë¬¸ìì—´ì—ì„œ ëˆ„ë½ë¨ì„ ì˜ë¯¸
	*/
	s2 := strings.Map(rot13, s1)
	fmt.Println(s2) // Guvf vf n grfg 123 ï¿½
	s3 := strings.Map(rot13, s2)
	fmt.Println(s3) // This is a test 123 ï¿½

}

// rot13(Rotate by 13)ì€ ì•”í˜¸(encryption) í•¨ìˆ˜ë¡œ, ì˜ì–´ ì•ŒíŒŒë²³ì˜ ë¬¸ìë¥¼ 13ìœ¼ë¡œ íšŒì „(rotate, ì¦‰ ë°€ì–´ì„œ) ì‹œì¼œì„œ ë§Œë“ ë‹¤
// https://ko.wikipedia.org/wiki/ROT13
func rot13(input rune) rune {
	// 'ë¬¸ì' ì²˜ëŸ¼ í™‘ë”°ì˜´í‘œ ì•ˆì— ë¬¸ìë¥¼ ìœ„ì¹˜ì‹œí‚¤ë©´ í•´ë‹¹ ë¬¸ìì˜ rune ê°’ì„ ì–»ì„ ìˆ˜ ìˆë‹¤
	if input >= 'A' && input <= 'Z' {
		/*
			[ëŒ€ë¬¸ìì¸ ê²½ìš°]
			(input -'A'): 'A'ì—ì„œ ì‹œì‘í•˜ë¯€ë¡œ 0ë¶€í„° ìµœëŒ€ 25
			(0 ~ 25) + 13: 13ë§Œí¼ ë°€ì–´ë‚¸ë‹¤
			((0 ~ 25) + 13) % 26: ì•ŒíŒŒë²³ì˜ ê°œìˆ˜(26)ìœ¼ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¡œ 0ë¶€í„° 25 ì‚¬ì´ì˜ ê°’ ì•ˆì—ì„œ íšŒì „(rotate)í•˜ê²Œ ëœë‹¤
			(((0 ~ 25) + 13) % 26) + 'A'(65): ìœ„ì—ì„œ ì—°ì‚°ëœ ê°’ì„ 'A'(ëŒ€ë¬¸ì ì•ŒíŒŒë²³ì˜ ì‹œì‘ê°’)ì— ë”í•˜ë©´ íšŒì „ ëœ ì•ŒíŒŒë²³ì˜ rune ë°˜í™˜í•œë‹¤
		*/
		return (((input - 'A') + 13) % 26) + 'A'
	}
	if input >= 'a' && input <= 'z' {
		return (((input - 'a') + 13) % 26) + 'a'
	}

	return input
}

func unicodeAndUtf8Pkgs() {
	s1 := "ğŸ˜€ ğŸ˜‘ ğŸŸ"
	fmt.Println(s1)
	fmt.Println(len(s1))                    // 14: number of bytes of string
	fmt.Println(utf8.RuneCountInString(s1)) // 5: number of characters in string
}

func mathPkgs() {
	/*
		func Cos(x float64) float64
		func Exp(x float64) float64
		func Log(x float64) float64
		func Min(x float64) float64
		func Max(x float64) float64
		ëª¨ë‘ float64ë¡œ ê³„ì‚°ëœë‹¤
		ì •ìˆ˜ ì—°ì‚°í•˜ê³  ì‹¶ë‹¤ë©´,
		1. íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê¸¸ ë•Œ float64()ë¡œ í˜•ë³€í™˜
		2. ì—°ì‚°
		3. ê²°ê³¼ê°’ì„ int()ë¡œ í˜•ë³€í™˜
	*/
	/*
		pseudo-random number generator
		func Seed(seed int64)  // ê°™ì€ ê°’ì„ ë„˜ê¸°ë©´, ë§¤ë²ˆ ê°™ì€ ìˆœì„œì˜ ìˆ«ìë“¤ì„ ë°˜í™˜ë°›ê²Œ ëœë‹¤. ë¬´ì‘ìœ„ ìˆ˜ ì›í•˜ë©´ timeì˜ unix nano ê°’ì„ ë„˜ê¸´ë‹¤
		func Intn(n int) int  // 0ë³´ë‹¤ í¬ê³  ì „ë‹¬ë˜ëŠ” int në³´ë‹¤ ì‘ì€ ë¬´ì‘ìœ„ ìˆ˜ ë°˜í™˜
	*/
	// í˜¸ì¶œ ì‹œë§ˆë‹¤ ë¬´ì‘ìœ„ ìˆ˜ë¥¼ ë°˜í™˜í•˜ê¸° ìœ„í•´ ì”¨ì•—(seed)ìœ¼ë¡œ int64 ë‚˜ë…¸ì´ˆ unix timeì„ ì‚¬ìš©
	rand.Seed(time.Now().UnixNano())
	r1 := rand.Intn(10)
	r2 := rand.Intn(10)
	a := int(math.Max(float64(r1), float64(r2)))
	fmt.Println(r1, r2, a)
}

func main() {
	fmt.Println("===========stringsPkgs===========")
	stringsPkgs()
	fmt.Println("===========unicodeAndUtf8Pkgs===========")
	unicodeAndUtf8Pkgs()
	fmt.Println("===========mathPkgs===========")
	mathPkgs()
}
